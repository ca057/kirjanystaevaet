% !TeX spellcheck = de_DE
\section{Lessons Learned}

	\subsection{weitere Kritik}	
		\paragraph{Naming conventions} Zwar wurde das Thema von einheitlichen Namen und Messages desöfteren angerissen, aber nicht konsequent umgesetzt. Dadurch existieren mehrere Stellen im Code, an denen eine abstraktere Verwendung von Strings und eine einheitliche Benennung von Variablen etc. von Vorteil gewesen wären. Gleiches gilt für die Benennung der Branches, die nicht einheitlich gehalten ist. Aufgrund der geringen Wahrscheinlichkeit, das Programm über längere Zeit warten zu müssen, lag auf einer Behebung dieser Umstände jedoch kein Fokus. Bei frühzeitiger Umsetzung sollte dies beim nächsten Projekt kein Problem sein.
		
		\paragraph{Datenbankschema} Zwar wurde immer wieder über das Datenbankschema diskutiert, aber es fehlte die Festlegung auf ein vollständiges Datenbankschema zu einem relativ frühen Zeitpunkt. Zwar wurde sich an das vorgegebene Datenbankschema aus dem Anforderungskatalog gehalten und dieses diente als gute Orientierung, doch wurden so etwas wie \texttt{stock}, \texttt{Orderx}, \texttt{OrderItem} und \texttt{UserBookStatistic} erst später eingeführt und in das schon bestehende System ergänzt. Dieses Vorgehen ist fehleranfällig und die Integration dieser Teile in ein Schema, bevor es implementiert wird, hätte die Implementierung erleichtert. Zudem hätte potentiell die \texttt{@Audited}-Annotation von \textit{JBoss Envers} die Versionsverwaltung von Büchern vereinfacht. Diese Möglichkeit wurde jedoch leider zu spät entdeckt, um sich sinnvoll damit befassen zu können.
		
		\paragraph{Einbindung von Springklassen} An manchen Stellen wäre die Verwendung von Springeigenen Klassen vorteilhaft beziehungsweise leichter gewesen. So implementiert beispielsweise die \textit{User}-Klasse nicht die gleichnamige Klasse, die von Spring angeboten wird. Darüber hätten bestimmte Funktionen (Account deaktivieren etc.) im späteren Verlauf leicht hinzugefügt werden können.
		
		\paragraph{Tests} Für die meisten Funktionen bestehen keine feste Testmethoden. Ausnahme ist die Klasse \textit{ServiceTest}, in der einige Tests für DAOs und Services existieren. Alle anderen Funktionen wurden nach dem Trial and Error-Prinzip angelegt. Erste Testversuche -- zum Beispiel für die Controller -- scheiterten schon an der korrekten Erstellung der Tests, da das Zusammenspiel der einzelnen Komponenten noch zu abstrakt und unbekannt war. Für ein größeres Projekt ist dies keine vernünftige Vorgehensweise und auch bei \textit{kirjanystaevaet} wäre testdriven developement mit Unit- und Integrationstests eine Möglichkeit gewesen. Aufgrund der langen Einarbeitungszeit in grundsätzliche Springfunktionsweisen blieben strukturierte Tests jedoch Theorie, dürften aber bei einem folgenden Spring-Projekt aufgrund der Kenntnisse des Frameworks einfacher fallen.

	\subsection{Lernerfolge}
		\paragraph{Hibernate} In bisherigen Projekten und Kursen basierte die Arbeit mit Datenbanken auf eigens generierten SQL-Abfragen. Dieses Projekt war daher eine gute Gelegenheit, objektrelationales Mapping und in diesem Kontext auch Hibernate kennenzulernen.
		
		\paragraph{Dependency Injection} Das Konzept der \textit{Inversion of Control} und die Verwendung von Beans war ein bisher unbekanntes Feld. Vor allem die Arbeit des Spring-Containers, der für die Erstellung und Verwaltung sämtlicher Beans verantwortlich ist, war anfangs gewöhnungsbedürftig.
		
		\paragraph{Server-seitige Absicherung}
		
		\paragraph{Zusammenspiel von Server und Client, Ablauf von "`Request"' und "`Response"'}
		Das bisher nur aus der Theorie bekannte Zusammenspiel zwischen Serveranfragen und -antworten konnte selbst konzipiert und implementiert werden. Verschiedene Möglichkeiten zur Datenübermittlung wurden ausprobiert, wie die Nutzung von Variablen in der URL, Anfrageparametern oder die Übermittlung von JSON. Neben der korrekten Verarbeitung der Anfragen war auch die Übermittlung einer logischen Antwort von Bedeutung. Auch im Fehlerfall musste dem Client ein Ergebnis übermittelt werden, welches dieser ohne weitere Kenntnisse der server-internen Abläufe korrekt interpretieren und nutzen kann.
		
		\paragraph{Git}
		Die Nutzung der verteilten Versionsverwaltung Git war für die Arbeit am Projekt unerlässlich. Neben den bekannten Standard-Funktionen mussten zu einigen Zeitpunkten "`komplexere"' Merge-Operationen durchgeführt werden oder auf einen früheren Stand gesprungen werden, was die Beschäftigung mit neuen Funktionen und ihren Seiteneffekten mit sich brachte.