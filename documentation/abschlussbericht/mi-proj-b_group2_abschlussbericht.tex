\documentclass{lni}
\let\ifpdf\relax

\IfFileExists{latin1.sty}{\usepackage{latin1}}{\usepackage{isolatin1}}

\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}

\lstset{basicstyle=\ttfamily,breaklines=true}

\author{
	Christian Ost, Madeleine Rosenhagen, Ludwig Thormann, Johannes Trepesch \\ 
	\\ 
	Abteilung \\ 
	Einrichtung \\ 
	Anschrift \\ 
	Postleitzahl Ort \\ 
	emaiaddresse@autor1 \\
	emaiaddresse@autor2
}
\title{Abschlusdokumentation -- kirjanystaevaet}


\begin{document}
\maketitle
\tableofcontents
\newpage

\begin{abstract}
Es folgt ein kurzer Überblick über die Arbeit.
\end{abstract}

\section{Einleitung}

\section{Systemarchitektur}

\section{Umsetzung des Anforderungskatalogs}
	\subsection{Datenmanagement}
	TODO: Allgemeines, zu Hibernate und weshalb wir das verwendet haben.
	\subsubsection{Datenbankschema}
	Überprüfen und Einfügen von Johannes Bild
	\subsubsection{Architektur der Datenbankfunktionen}
	Da in diesem Projekt Hibernate verwendet wird, wurde für jede Entität eine Klasse erstellt, die alle Daten anhand von Instanzvariablen enthält. Verknüpfungen zu anderen Entitäten werden hergestellt, indem eine Entität eine Collection einer anderen Entität hält. Über Annotationen werden die Eigenschaften der einzelnen Spalten definiert. So lässt sich beispielsweise über \texttt{@Id} angeben, dass es sich bei dieser Variable um den Primärschlüssel handelt. In den meisten Fällen werden die Ids beim Einfügen automatisch generiert. Nur in der Klasse \texttt{book} fungiert die ISBN als Schlüssel. Weiterhin werden über die Annotationen die Beziehungen zu anderen Entitäten definiert. Hierbei können ebenfalls verschiedene Einstellungen vorgenommen werden.\\
	Zum einen werden die \texttt{FetchTypes} festgelegt. \texttt{LAZY} bedeutet hierbei, dass die verknüpften Entitäten bei einer Datenbankabfrage nicht mitgeladen werden. Das wurde hier bei \texttt{books} in \texttt{Category} so gehandhabt. Wenn man z.B. nur die Liste aller vorhanden Kategorien aus der Datenbank abfragen will, werden die einzelnen Bücher häufig gar nicht benötigt. Bei dieser Einstellung werden sie nicht mitgeladen und so der Datentransfer klein gehalten. Um die Bücher einer Kategorie zu bekommen, wird eine gesonderte Abfrage gemacht. Anders sieht es bei \texttt{authors} in \texttt{Book} aus. Diese werden häufig benötigt und da es sich nicht um viele Autor-Datensätze pro Buch handelt, stellt es keinen Nachteil dar, sie sofort aus der Datenbank zu laden. Dafür wird der \texttt{FetchType} auf \texttt{EAGER} gesetzt. Bei allen Verknüpfungen, die mit \texttt{User} und \texttt{Order} zusammenhängen, verhält es sich ebenso.\\
	Außerdem wird der \texttt{CascadeType} bestimmt. So wird geregelt, dass wenn z.B. das letzte Buch einer Kategorie gelöscht werden sollte, die entsprechende \textit{Category} nicht ebenfalls gelöscht wird, da diese einen hohen Wiederverwendungswert haben. Andererseits würde ein \texttt{Author} eines Buches gelöscht werden, wenn er mit keinem Buch sonst mehr verknüpft ist (allgemein zum Löschen von Büchern siehe \textbf{REF}).
	\\
	\\
	Die Datenbankzugriffe finden in den \textit{Data Access Objects (DAOs)} statt, die es für jede Entität gibt. Diese sind \textit{Trans\-actio\-nal} \textbf{Johannes, kannst du mehr dazu sagen?} und werden möglichst klein gehalten. Nur in seltenen Fällen enthalten diese Logik. Eine Ausnahme ist die \texttt{createOrder}-Methode im \texttt{OrderDao}, da im Zuge einer Bestellung auch der Bestand angepasst werden muss und Konsistenz sichergestellt sein muss (siehe \textbf{REF}).\\
	Der Aufruf der \textit{DAOs} erfolgt über die \textit{Services}. Diese enthalten sehr viel mehr Logik und das Exception Handling (siehe \textbf{ref}). An dieser Stelle werden Daten verarbeitet, in eine andere Form gebracht und bei Bedarf sortiert und dann eine Schicht weiter nach oben gegeben. Unter anderem deshalb sind die \textit{Services} sehr viel umfangreicher als die \textit{DAOs}. Außerdem fassen sie mehr zusammen, da beispielsweise der \texttt{DataService} alles Funktionen für die Verarbeitung der Entitäten \texttt{Book}, \texttt{Category} und \texttt{Author} enthält, da diese sehr stark zusammenhänngen. Weiterhin gibt es einen \texttt{OrderService} für die Verwaltung der Entitäten \texttt{Order} und \texttt{OrderItem}. Die Funktionalität, die den \texttt{User} betreffen, befinden sich im \texttt{UserService}. \textbf{Johannes} 
	
	To be continued
	\subsection{REST-API}
	Die REST-API liefert Bestandsdaten im JSON-Format über die zum Verkauf stehenden Bücher. Tabelle \ref{rest-api} gibt Auskunft über das verwendete URL-Schema, dabei muss der angegebenen URL \lstinline|http://localhost:8080/kirjanystaevaet/api/v1| vorangestellt werden.
	
	\begin{table}[h]
		\caption{URL-Schema der REST-API}
		\begin{tabular}{|c|c|c|c|}
			\hline
			URL & (optionale) Parameter & Methode & Beschreibung \\ \hline \hline
			\lstinline|/books| & \lstinline|limit (long)| & \lstinline|GET| & alle verfügbaren Bücher \\ \hline
			\lstinline|/books/{category}| & \lstinline|limit (long)| & \lstinline|GET| & alle verfügbaren Bücher der übergebenen Kategorie \\ \hline
			\lstinline|/books/{isbn}| & & \lstinline|GET| & das Buch mit der übergebenen ISBN \\ \hline
		\end{tabular} 
		\label{rest-api}
	\end{table}
	
\section{User Stories}
	\subsection{Registrierung und Login}
	\dots
	
	Da es zu einer Postleitzahl mehrere Orte geben kann, zum Beispiel bei \lstinline|37627|, wird dem Nutzer nach Eingabe einer Postleitzahl eine Liste mit allen zutreffenden Ortsnamen angezeigt. Aus dieser ist der korrekte Ort auszuwählen. Die möglichen Orte werden im Hintergrund über eine AJAX-Abfrage vom Server geholt und als Radio-Buttons in die HTML-Seite eingefügt.
	
	\dots
	
	\subsection{Buchauswahl und Bestellung}
	
	\subsection{Administration des Web-Shops}

\section{Zusammenarbeit}
	\begin{itemize}
		\item git
		\item GitHub-Issues
		\item Austausch/Updates per Mail
		\item wöchentliche Treffen
	\end{itemize}
	
\section{Lessons Learned}
	\begin{itemize}
		\item[Git] Wie lösen wir Merge-Konflikte? Wie teilen wir die Arbeit auf unterschiedliche Branches aus? Wie halten wir unseren Master einigermaßen fehlerfrei?
		\item[Naming Conventions] Wie benennen wir unsere Feature-Branches? Wie benennen wir unsere Klassen? Wie benennen wir unsere Packages?
	\end{itemize}
	
\bibliography{lnitemplate}

\end{document}
