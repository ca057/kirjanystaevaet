\section{Umsetzung des Anforderungskatalogs}\label{sec:umsetzung}
	\subsection{Datenbank}\label{sec:umsetzung:DB:DBS}
	\subsubsection{Datenbankschema}\label{sec:umsetzung:DB:Schema}
	
	Das Datenbankschema war zum Teil bereits gegeben. Hinzu kamen die Abschnitte zu Nutzer\_innen und Bestellungen. Um auch bei Änderungen des Preises in Bestellungen den Kaufpreis eines Buches in einer bestimmten Bestellung nicht zu verlieren, existiert die Tabelle OrderItem, die den zum Kauf gültigen Preis sichert. Um diese OrderItems in mehreren Bestellungen nutzen zu können, sind sie über eine m:n-Verbindung mit der Order-Tabelle verknüpft. Diese 
	
	Nutzer\_innen halten über eine 1:n-Verbindung beliebig viele Orders. Zudem sind sie über eine Zwischentabelle mit Books assoziiert, in der verschiedene user- und buchspezifische Daten gespeichert sind. In der aktuellen Umsetzung sind das die Anzahl an Aufrufen eines bestimmten Buches über einen bestimmten Account sowie das Datum des letzten Aufrufs.
	
%	\includesvg{files/db-schema}
	
	\subsection{Datenmanagement}\label{sec:umsetzung:DB:DM}
	Grundlage der Datenverwaltung von \textit{kirjanystaevaet} ist die Java-SQL-Datenbank H2. Sie bietet in unseren Augen die für unsere Anforderungen beste Gewichtung von Funktionsumfang und Nutzungsfreundlichkeit. Zum einen ist die Datenbank selbst klein, zum anderen ohne größere Probleme und zusätzliche Fragestellungen (Server etc.) einzurichten. Trotzdem kann bei Bedarf auch eine kompliziertere Konfiguration vorgenommen werden. Die Datenbank von \textit{kirjanystaevaet} läuft auf dem gleichen Server wie die Anwendung selbst. Das Programm greift dabei lokal auf die Daten zu, startet dabei aber den H2 inhärenten Server, sodass theoretisch auch andere Software die Datenbank gleichzeitig nutzen könnten. Im aktuellen Anwendungsfall ist dies aber zu vernachlässigen.
	
	In \textit{kirjanystaevaet} schließlich kommt Hibernate für objektrelationales Mapping zum Einsatz. Ziel ist es, einem Datensatz aus der Datenbank ein Java-Objekt zuzuordnen. Die Entscheidung zu dieser Vorgehensweise fiel vor allem aus persönlichem Interesse sowie aus Erfahrungen mit der Programmierung von rein SQL-basierten Anwendungen und den damit verbundenen Schwierigkeiten, kompliziertere Datenbankanfragen dynamisch zu konstruieren. Zwar kann es bei größeren Abfrageergebnissen mit vielen genesteten Objekten (bei ManyToMany-Verbindungen) bei unvorsichtiger Konfiguration schnell zu großen (unnützen) Datenmengen kommen, bei der abzuschätzenden Größe des Büchershops sollten sich diese Probleme jedoch im Rahmen halten. Wie im folgenden beschrieben, wurde im Programm dennoch eine überlegte Verwendung der FetchTypes eager und lazy angestrebt.
		
	\subsubsection{Architektur der Datenbankfunktionen}\label{sec:umsetzung:DB:Funktionen}
	Da in diesem Projekt Hibernate verwendet wird, wurde für jede Entität eine Klasse erstellt, die alle Daten anhand von Instanzvariablen enthält. Verknüpfungen zu anderen Entitäten werden hergestellt, indem eine Entität eine Collection einer anderen Entität hält. Über Annotationen werden die Eigenschaften der einzelnen Spalten definiert. So lässt sich beispielsweise über \texttt{@Id} angeben, dass es sich bei dieser Variable um den Primärschlüssel handelt. In den meisten Fällen werden die Ids beim Einfügen automatisch generiert. Nur in der Klasse \texttt{book} fungiert die ISBN als Schlüssel. Weiterhin werden über die Annotationen die Beziehungen zu anderen Entitäten definiert. Hierbei können ebenfalls verschiedene Einstellungen vorgenommen werden.\\
	Zum einen werden die \texttt{FetchTypes} festgelegt. \texttt{LAZY} bedeutet hierbei, dass die verknüpften Entitäten bei einer Datenbankabfrage nicht mitgeladen werden. Das wurde hier bei \texttt{books} in \texttt{Category} so gehandhabt. Wenn man z.B. nur die Liste aller vorhanden Kategorien aus der Datenbank abfragen will, werden die einzelnen Bücher häufig gar nicht benötigt. Bei dieser Einstellung werden sie nicht mitgeladen und so der Datentransfer klein gehalten. Um die Bücher einer Kategorie zu bekommen, wird eine gesonderte Abfrage gemacht. Anders sieht es bei \texttt{authors} in \texttt{Book} aus. Diese werden häufig benötigt und da es sich nicht um viele Autor-Datensätze pro Buch handelt, stellt es keinen Nachteil dar, sie sofort aus der Datenbank zu laden. Dafür wird der \texttt{FetchType} auf \texttt{EAGER} gesetzt. Bei allen Verknüpfungen, die mit \texttt{User} und \texttt{Order} zusammenhängen, verhält es sich ebenso.\\
	Außerdem wird der \texttt{CascadeType} bestimmt. So wird geregelt, dass wenn z.B. das letzte Buch einer Kategorie gelöscht werden sollte, die entsprechende \textit{Category} nicht ebenfalls gelöscht wird, da diese einen hohen Wiederverwendungswert haben. Andererseits würde ein \texttt{Author} eines Buches gelöscht werden, wenn er mit keinem Buch sonst mehr verknüpft ist (allgemein zum Löschen von Büchern siehe \textbf{REF}).
	\\
	\\
	Die Datenbankzugriffe finden in den \textit{Data Access Objects (DAOs)} statt, die es für jede Entität gibt. Diese sind \textit{Trans\-actio\-nal} \textbf{Johannes, kannst du mehr dazu sagen?} und werden möglichst klein gehalten. Nur in seltenen Fällen enthalten diese Logik. Eine Ausnahme ist die \texttt{createOrder}-Methode im \texttt{OrderDao}, da im Zuge einer Bestellung auch der Bestand angepasst werden muss und Konsistenz sichergestellt sein muss (siehe \textbf{REF}).\\
	Der Aufruf der \textit{DAOs} erfolgt über die \textit{Services}. Diese enthalten sehr viel mehr Logik und das Exception Handling (siehe \textbf{ref}). An dieser Stelle werden Daten verarbeitet, in eine andere Form gebracht und bei Bedarf sortiert und dann eine Schicht weiter nach oben gegeben. Unter anderem deshalb sind die \textit{Services} sehr viel umfangreicher als die \textit{DAOs}. Außerdem fassen sie mehr zusammen, da beispielsweise der \texttt{DataService} alles Funktionen für die Verarbeitung der Entitäten \texttt{Book}, \texttt{Category} und \texttt{Author} enthält, da diese sehr stark zusammenhängen. Weiterhin gibt es einen \texttt{OrderService} für die Verwaltung der Entitäten \texttt{Order} und \texttt{OrderItem}. Die Funktionalität, die den \texttt{User} betreffen, befinden sich im \texttt{UserService}. \textbf{Johannes} Im Verlauf des Projekts wurde häufig diskutiert, welche Datentypen der \textit{Service} weiter geben darf und ob es zu Problemen kommen kann, wenn direkt die Entitäten der Objekte weiter gereicht werden. Es wurde entschieden, dass die Objekte weitergegeben werden, allerdings wurden sie mithilfe von \textit{Buildern} als unveränderbar konstruiert. (siehe \textbf{REF Johannes}).\\ 
	Ein hilfreiches Mittel zum Datenaustausch sind weiterhin die \textit{Enum}, die die Felder der Entitäten, bzw die Spalten der Datenbanktabellen abbilden. Ein gutes Beispiel für die Verwendung der \textit{Enums} ist die \texttt{insertBook}-Methode des \texttt{DataService}. Hier werden dem \texttt{Service} über eine \texttt{Map\textless Searchfields, String\textgreater } alle notwendigen Daten übergeben, wobei das Enum im Key die Zugehörigkeit der Daten im Value angibt. Auch bei der Suche über Metadaten werden die Daten auf diese Weise an den \textit{Service} übergeben.
	\subsubsection{Einfügen von Daten}
	Soll ein Buch eingefügt werden, ist es wichtig, dass die zugehörigen Kategorien und Autoren schon vorher in der Datenbank gespeichert sind. Autoren erfahren hier außerdem eine spezielle Behandlung. Soll ein neuer Autor eingefügt werden, wird überprüft, ob es schon einen Autor mit exakt diesem Namen gibt und wenn ja, nochmals nachgefragt, ob es sich tatsächlich um eine neue Person handelt oder vielleicht eine der schon vorhandenen gemeint ist. Das trägt der Tatsache Rechnung, dass auch die Kombination von Vor- und Nachnamen keineswegs eindeutig sind. 
	\subsubsection{Löschen von Daten}
	Das Löschen von Daten ist nur eingeschränkt möglich. Prinzipiell bieten die \textit{DAOs} die entsprechenden Funktionen dafür an. Zumindest bei Büchern werden sie von der entsprechenden Methode im Service jedoch nicht verwendet. Da es ein Bestell-Archiv gibt, das heißt jeder User kann jede Bestellung, die einmal getätigt wurde, einsehen, ist es nicht möglich die Datensätze zu löschen, auch wenn das Buch nicht mehr angeboten wird. In welchen Zustand sich ein Buch befindet wird über die Spalte \texttt{stock} geregelt. Im Prinzip zeigt diese an, wie viele Exemplare von einem Buch vorrätig sind, ist der Wert jedoch negativ, bedeutet das, dass das Buch nicht mehr verkauft gilt. Ruft man im Service also die \texttt{deleteBook}-Methode auf, wird nur der \texttt{stock} auf \texttt{-1} gesetzt.\\
	Daraus folgt, dass auch Kategorien und Autoren nicht gelöscht werden können, da dies nur möglich wäre, wenn keine Bücher mehr vorhanden wären, die mit dem jeweiligen Datensatz verknüpft sind.
	\subsubsection{Ändern von Daten}
	Ursprünglich war vorgesehen, dass nur sehr wenig an Büchern geändert werden kann, da die meisten Angaben von der ISBN abhängig sind. So kann sich der Titel einer Ausgabe nicht ändern. Veränderungen in den Daten, die in diesem Fall in der Datenbank gespeichert werden, erfordern eigentlich auch eine neue ISBN\footnote{siehe hierzu \url{https://de.wikipedia.org/wiki/Internationale_Standardbuchnummer} unter \textit{Regeln zur ISBN-Vergabe und -Nutzung}}. Solch ein restriktives Vorgehen würde jedoch zu anderen Problemen führen, nämlich dass z.B. Tippfehler, die ein Admin beim einfügen neuer Bücher macht, nicht ausgebessert werden können. Aus diesem Grund haben wir entschieden, dass bei Büchern alle Daten bis auf die ISBN geändert werden können und die Verantwortung für korrekte Daten damit dem Admin überlassen.

	\subsubsection{Exception Handling}
	Im Umgang mit der Datenbank können viele Fehler auftreten. Durch ein umfassendes Exception-Handling wird versucht den Shop vor dem Absturz zu bewahren.\\	
	Es wurde viel darüber nachgedacht und diskutiert, wie man die oberen Schichten über Fehler oder unerwartetes Verhalten informieren kann, wenn es geht auch ohne Exceptions. Die Probleme liegen darin, wenn ein einzelnes Objekt in der Datenbank gesucht wird und der Rückgabetyp des entsprechenden Services keine \texttt{List\textless..\textgreater}, sondern vom Typ der entsprechenden Entität ist. Es soll unbedingt vermieden bei einer erfolglosen Suche null zurückzugeben. Ein anderer Fall liegt vor, wenn versucht wird eine Entität zu löschen, die nicht existiert oder eine Entität in die Datenbank zu speichern, die schon existiert. Im Sinne der Nutzerfreundlichkeit ist es sinnvoll, zu informieren, dass ein Objekt nicht gelöscht wurde, da es nicht existiert. Solche Fehler können z.B. durch Tippfehler in der Eingabe entstehen und dann zu unerwartetem Verhalten führen, wie z.B. das Objekt, das eigentlich gelöscht werden sollte, ist immer noch vorhanden.\\	
	Eine Idee war es Enums zu verwenden, die den Status eines Vorgangs angeben (z.B. \texttt{delete succssful} o.ä.) und überprüft werden können, um dementsprechend zu handeln. Der gravierende Nachteil dieser Lösung ist, dass sie nur bei \texttt{void}-Methoden anwendbar ist. Aus diesem Grund haben wir uns gegen diese Idee entschieden und sind doch dabei geblieben, bei Fehlern Exceptions zu werfen, um alle Probleme durchgängig einheitlich behandeln zu können.\\	
	Dabei haben wir darauf geachtet, so weit es möglich ist, nur eine Exception an die oberen Schichten weiter zu geben, nämlich die \texttt{DatabaseException}. Ihr werden mithilfe des \texttt{ErrorMessageHelpers} sehr spezifische, aber einheitliche Fehlernachrichten mitgegeben, die dann z.B. dem Nutzer, v.a. wenn es sich um den Admin handelt, angezeigt werden können.\\	
	Zudem wurde auf diese Weise versucht, \texttt{HibernateExceptions} schon auf der Ebene der \textit{Daos} und \textit{Services} abzufangen und ebenfalls in eine \texttt{DatabaseException} umzuwandeln. Es soll so verhindert werden, dass unchecked Exceptions den Shop zum Absturz bringen.

	\subsection{Suchfunktion}
	Die Suchfunktion wird im \texttt{DataService} angeboten. Hierbei wurde sich auf eine Suche über die Metadaten beschränkt. Es kann nach \textit{Titel}, \textit{Vorname}, \textit{Nachname}, \textit{ISBN}, \textit{Erscheinungsjahr} und \textit{Kategorie} gesucht werden. Die Angaben werden und-verknüpft. 


	\subsection{REST-API}\label{sec:umsetzung:Rest}

	Die REST-API liefert Bestandsdaten im JSON-Format über die zum Verkauf stehenden Bücher. Tabelle \ref{rest-api} gibt Auskunft über das verwendete URL-Schema, dabei muss der angegebenen URL \lstinline|http://localhost:8080/kirjanystaevaet/api/v1| vorangestellt werden.
	
	\begin{table}[h]
		\caption{URL-Schema der REST-API}
		\begin{tabular}{|c|c|c|c|}
			\hline
			URL & (optionale) Parameter & Methode & Beschreibung \\ \hline \hline
			\lstinline|/books| & \lstinline|limit (long)| & \lstinline|GET| & alle verfügbaren Bücher \\ \hline
			\lstinline|/books/{category}| & \lstinline|limit (long)| & \lstinline|GET| & alle verfügbaren Bücher der übergebenen Kategorie \\ \hline
			\lstinline|/books/{isbn}| & & \lstinline|GET| & das Buch mit der übergebenen ISBN \\ \hline
		\end{tabular} 
		\label{rest-api}
	\end{table}