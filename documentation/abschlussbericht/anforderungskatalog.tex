\section{Umsetzung des Anforderungskatalogs}
	\subsection{Datenmanagement}
	TODO: Allgemeines, zu Hibernate und weshalb wir das verwendet haben.
	\subsubsection{Datenbankschema}
	Überprüfen und Einfügen von Johannes Bild
	\subsubsection{Architektur der Datenbankfunktionen}
	Da in diesem Projekt Hibernate verwendet wird, wurde für jede Entität eine Klasse erstellt, die alle Daten anhand von Instanzvariablen enthält. Verknüpfungen zu anderen Entitäten werden hergestellt, indem eine Entität eine Collection einer anderen Entität hält. Über Annotationen werden die Eigenschaften der einzelnen Spalten definiert. So lässt sich beispielsweise über \texttt{@Id} angeben, dass es sich bei dieser Variable um den Primärschlüssel handelt. In den meisten Fällen werden die Ids beim Einfügen automatisch generiert. Nur in der Klasse \texttt{book} fungiert die ISBN als Schlüssel. Weiterhin werden über die Annotationen die Beziehungen zu anderen Entitäten definiert. Hierbei können ebenfalls verschiedene Einstellungen vorgenommen werden.\\
	Zum einen werden die \texttt{FetchTypes} festgelegt. \texttt{LAZY} bedeutet hierbei, dass die verknüpften Entitäten bei einer Datenbankabfrage nicht mitgeladen werden. Das wurde hier bei \texttt{books} in \texttt{Category} so gehandhabt. Wenn man z.B. nur die Liste aller vorhanden Kategorien aus der Datenbank abfragen will, werden die einzelnen Bücher häufig gar nicht benötigt. Bei dieser Einstellung werden sie nicht mitgeladen und so der Datentransfer klein gehalten. Um die Bücher einer Kategorie zu bekommen, wird eine gesonderte Abfrage gemacht. Anders sieht es bei \texttt{authors} in \texttt{Book} aus. Diese werden häufig benötigt und da es sich nicht um viele Autor-Datensätze pro Buch handelt, stellt es keinen Nachteil dar, sie sofort aus der Datenbank zu laden. Dafür wird der \texttt{FetchType} auf \texttt{EAGER} gesetzt. Bei allen Verknüpfungen, die mit \texttt{User} und \texttt{Order} zusammenhängen, verhält es sich ebenso.\\
	Außerdem wird der \texttt{CascadeType} bestimmt. So wird geregelt, dass wenn z.B. das letzte Buch einer Kategorie gelöscht werden sollte, die entsprechende \textit{Category} nicht ebenfalls gelöscht wird, da diese einen hohen Wiederverwendungswert haben. Andererseits würde ein \texttt{Author} eines Buches gelöscht werden, wenn er mit keinem Buch sonst mehr verknüpft ist (allgemein zum Löschen von Büchern siehe \textbf{REF}).
	\\
	\\
	Die Datenbankzugriffe finden in den \textit{Data Access Objects (DAOs)} statt, die es für jede Entität gibt. Diese sind \textit{Trans\-actio\-nal} \textbf{Johannes, kannst du mehr dazu sagen?} und werden möglichst klein gehalten. Nur in seltenen Fällen enthalten diese Logik. Eine Ausnahme ist die \texttt{createOrder}-Methode im \texttt{OrderDao}, da im Zuge einer Bestellung auch der Bestand angepasst werden muss und Konsistenz sichergestellt sein muss (siehe \textbf{REF}).\\
	Der Aufruf der \textit{DAOs} erfolgt über die \textit{Services}. Diese enthalten sehr viel mehr Logik und das Exception Handling (siehe \textbf{ref}). An dieser Stelle werden Daten verarbeitet, in eine andere Form gebracht und bei Bedarf sortiert und dann eine Schicht weiter nach oben gegeben. Unter anderem deshalb sind die \textit{Services} sehr viel umfangreicher als die \textit{DAOs}. Außerdem fassen sie mehr zusammen, da beispielsweise der \texttt{DataService} alles Funktionen für die Verarbeitung der Entitäten \texttt{Book}, \texttt{Category} und \texttt{Author} enthält, da diese sehr stark zusammenhänngen. Weiterhin gibt es einen \texttt{OrderService} für die Verwaltung der Entitäten \texttt{Order} und \texttt{OrderItem}. Die Funktionalität, die den \texttt{User} betreffen, befinden sich im \texttt{UserService}. \textbf{Johannes} Im Verlauf des Projekts wurde häufig diskutiert, welche Datentypen der \textit{Service} weiter geben darf und ob es zu Problemen kommen kann, wenn direkt die Entitäten der Objekte weiter gereicht werden. Es wurde entschieden, dass die Objekte weitergegeben werden, allerdings wurden sie mithilfe von \textit{Buildern} als unveränderbar konstruiert. (siehe \textbf{REF Johannes}).\\ 
	Ein hilfreiches Mittel zum Datenaustausch sind weiterhin die \textit{Enum}, die die Felder der Entitäten, bzw die Spalten der Datenbanktabellen abbilden. Ein gutes Beispiel für die Verwendung der \textit{Enums} ist die \texttt{insertBook}-Methode des \texttt{DataService}. Hier werden dem \texttt{Service} über eine \texttt{Map\textless Searchfields, String\textgreater } alle notwendigen Daten übergeben, wobei das Enum im Key die Zugehörigkeit der Daten im Value angibt. Auch bei der Suche über Metadaten werden die Daten auf diese Weise an den textit{Service} übergeben.
	\subsubsection{Einfügen von Daten}
	Soll ein Buch eingefügt werden, ist es wichtig, dass die zugehörigen Kategorien und Autoren schon vorher in der Datenbank gespeichert sind. Autoren erfahren hier außerdem eine spezielle Behandlung. Soll ein neuer Autor eingefügt werden, wird überprüft, ob es schon einen Autor mit exakt diesem Namen gibt und wenn ja, nochmals nachgefragt, ob es sich tatsächlich um eine neue Person handelt oder vielleicht eine der schon vorhandenen gemeint ist. Die trägt der Tatsache Rechnung, dass auch die Kombination von Vor- und Nachnamen keineswegs eindeutig sind.
	\subsubsection{Löschen von Daten}
	Das Löschen von Daten ist nur eingeschränkt möglich. Prinzipiell bieten die \textit{DAOs} die entsprechenden Funktionen dafür an. Zumindest bei Büchern werden sie von der entsprechenden Methode im Service jedoch nicht verwendet. Da es ein Bestell-Archiv gibt, das heißt jeder User kann jede Bestellung, die einmal getätigt wurde, einsehen, ist es nicht möglich die Datensätze zu löschen, auch wenn das Buch nicht mehr angeboten wird. In welchen Zustand sich ein Buch befindet wird über die Spalte \texttt{stock} geregelt. Im Prinzip zeigt diese an, wie viele Exemplare von einem Buch vorrätig sind, ist der Wert jedoch negativ, bedeutet das, dass das Buch nicht mehr verkauft gilt. Ruft man im Service also die \texttt{deleteBook}-Methode auf, wird nur der \texttt{stock} auf \texttt{-1} gesetzt.\\
	Daraus folgt, dass auch Kategorien und Autoren nicht gelöscht werden können, da dies nur möglich wäre, wenn keine Bücher mehr vorhanden wären, die mit dem jeweiligen Datensatz verknüpft sind.
	\subsubsection{Ändern von Daten}
	\subsubsection{Exception Handling}
	\subsection{REST-API}
	Die REST-API liefert Bestandsdaten im JSON-Format über die zum Verkauf stehenden Bücher. Tabelle \ref{rest-api} gibt Auskunft über das verwendete URL-Schema, dabei muss der angegebenen URL \lstinline|http://localhost:8080/kirjanystaevaet/api/v1| vorangestellt werden.
	
	\begin{table}[h]
		\caption{URL-Schema der REST-API}
		\begin{tabular}{|c|c|c|c|}
			\hline
			URL & (optionale) Parameter & Methode & Beschreibung \\ \hline \hline
			\lstinline|/books| & \lstinline|limit (long)| & \lstinline|GET| & alle verfügbaren Bücher \\ \hline
			\lstinline|/books/{category}| & \lstinline|limit (long)| & \lstinline|GET| & alle verfügbaren Bücher der übergebenen Kategorie \\ \hline
			\lstinline|/books/{isbn}| & & \lstinline|GET| & das Buch mit der übergebenen ISBN \\ \hline
		\end{tabular} 
		\label{rest-api}
	\end{table}